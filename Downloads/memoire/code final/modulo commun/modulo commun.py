#!/usr/bin/env python3
import libnum
import gmpy2

def common_modulus(n, c1, c2, e1, e2):
    assert(libnum.gcd(e1, e2))
    _, s1, s2 = gmpy2.gcdext(e1, e2)#扩展欧几里得算法
    #若s1<0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。
    if s1 < 0:
        s1 = -s1
        c1 = gmpy2.invert(c1, n)
    if s2 < 0:
        s2 = -s2
        c2 = gmpy2.invert(c2, n)
    return pow(c1, s1, n)*pow(c2, s2, n)%n
n=65368919399961532350928035432667426448455143057049227906755090839541812321959735131004826294781545577293844350633708744312724097142811571918989191822981434187132448694463749284424155433595434905780977276776845615439460539606454318543187185774809569860717387816643187066482383562413696836869431140747161982359
c1 = 811406970222751526149926697009402913092473579284322883038824941369373
c2 = 1294438499993263872044401155001753261347663405773293008800457111730921019394633135266821613
e1 = 13
e2 = 17
print(common_modulus(n, c1, c2, e1, e2))
